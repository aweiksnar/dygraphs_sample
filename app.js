// Generated by CoffeeScript 1.7.1
(function() {
  var CanvasState, Shape, canvasState, graph, item, onDoubleClick, onMouseDown, onMouseMove, onMouseUp;

  Shape = (function() {
    function Shape(start, bottomHeight, finish, topHeight, fill) {
      var _ref, _ref1;
      this.start = (_ref = Math.min(start, finish)) != null ? _ref : 0;
      this.bottomHeight = bottomHeight != null ? bottomHeight : 0;
      this.finish = (_ref1 = Math.max(start, finish)) != null ? _ref1 : 1;
      this.topHeight = topHeight != null ? topHeight : 1;
      this.fill = fill != null ? fill : "rgba(255, 255, 0, .6)";
      this.width = Math.abs(this.start - this.finish);
    }

    Shape.prototype.draw = function(ctx, g) {
      var scale, width;
      ctx.fillStyle = this.fill;
      width = g.xAxisRange()[1];
      scale = g.toDomXCoord(g.xAxisRange()[1]);
      return ctx.fillRect(g.toDomXCoord(Math.min(this.start, this.finish)), this.bottomHeight, Math.abs(g.toDomXCoord(this.start) - g.toDomXCoord(this.finish)), this.topHeight);
    };

    return Shape;

  })();

  CanvasState = (function() {
    function CanvasState(graph) {
      this.graph = graph;
      this.ctx = graph.hidden_ctx_;
      this.canvas = graph.canvas;
      this.annotations = [];
    }

    CanvasState.prototype.addAnnotation = function(annotation) {
      return this.annotations.push(annotation);
    };

    CanvasState.prototype.redrawMarks = function() {
      var shape, _i, _len, _ref, _results;
      _ref = this.annotations;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shape = _ref[_i];
        _results.push(shape.draw(this.ctx, this.graph));
      }
      return _results;
    };

    return CanvasState;

  })();

  onMouseDown = function(event, g, context) {
    return context.initializeMouseDown(event, g, context);
  };

  onDoubleClick = function(event, g, context) {
    return g.updateOptions({
      dateWindow: null,
      valueRange: null
    });
  };

  onMouseMove = function(event, g, context) {};

  onMouseUp = function(event, g, context) {
    var a, coordinates, finish, i, shape, start, _i, _len, _ref, _results;
    start = g.toDataXCoord(context.dragStartX);
    finish = g.toDataXCoord(event.layerX);
    if (start <= 0 || finish <= 0) {
      return;
    }
    console.log("start", start, "finish", finish);
    shape = new Shape(start, g.layout_.area_.y, finish, g.layout_.area_.h);
    shape.draw(g.hidden_ctx_, g);
    canvasState.addAnnotation(shape);
    _ref = canvasState.annotations;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      a = _ref[i];
      coordinates = "" + a.start + ", " + a.finish + "</br>";
      if (i === canvasState.annotations.length - 1) {
        _results.push(document.getElementById('annotations').innerHTML += coordinates);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  graph = new Dygraph(document.getElementById("graph"), (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = light_curve_data.length; _i < _len; _i++) {
      item = light_curve_data[_i];
      _results.push([item['x'], item['y']]);
    }
    return _results;
  })(), {
    drawPoints: true,
    drawXGrid: true,
    drawYGrid: false,
    drawAxesAtZero: true,
    strokeWidth: 0,
    width: 1000,
    height: 400,
    isZoomedIgnoreProgrammaticZoom: true,
    showLabelsOnHighlight: false,
    interactionModel: {
      mousedown: onMouseDown,
      mousemove: onMouseMove,
      mouseup: onMouseUp,
      dblclick: onDoubleClick
    },
    showRangeSelector: true,
    rangeSelectorHeight: 30,
    rangeSelectorPlotStrokeColor: 'grey',
    rangeSelectorPlotFillColor: 'lightgrey',
    hideOverlayOnMouseOut: false,
    highlightSeriesBackgroundAlpha: 1,
    highlightSeriesOpts: {
      highlightCircleSize: 0
    },
    drawCallback: function() {
      return typeof canvasState !== "undefined" && canvasState !== null ? canvasState.redrawMarks() : void 0;
    },
    underlayCallback: function(canvas, area, g) {
      var bottom_left, left, right, top_right;
      console.log("canvas", canvas, "Area", area, "g", g);
      bottom_left = g.toDomCoords(0, -20);
      top_right = g.toDomCoords(area.w, +20);
      left = bottom_left[0];
      right = top_right[0];
      canvas.fillStyle = "#000";
      return canvas.fillRect(left, area.y, right - left, area.h);
    }
  });

  canvasState = new CanvasState(graph);

  window.canvasState = canvasState;

}).call(this);
